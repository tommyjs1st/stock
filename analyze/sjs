    """
    EnhancedStockAnalyzerÏùò analyze_stock Î©îÏÑúÎìú ÏµúÏ¢Ö ÏàòÏ†ïÎ≥∏
    Î™®Îì† Î≤ÑÍ∑∏ ÏàòÏ†ï:
    1. _record_individual_signalsÏóê score Ïù∏Ïûê Ï∂îÍ∞Ä ‚úÖ
    2. _record_signal_combination Ìò∏Ï∂úÏùÑ Ïù∏ÎùºÏù∏ ÏΩîÎìúÎ°ú ÍµêÏ≤¥ ‚úÖ
    """
    
    def analyze_stock(self, name, code):
        """
        Í∞úÎ≥Ñ Ï¢ÖÎ™© Î∂ÑÏÑù (Ï†àÎåÄÏ°∞Í±¥ ÌïÑÌÑ∞ÎßÅ Ï†ÅÏö©)
        Î≤ÑÍ∑∏ ÏàòÏ†ï ÏôÑÎ£å Î≤ÑÏ†Ñ
        """
        try:
            # Ïô∏Íµ≠Ïù∏ ÏàúÎß§Ïàò Ï∂îÏÑ∏ ÌôïÏù∏ (ÏïàÏ†ÑÌïú Ìò∏Ï∂ú)
            try:
                foreign_netbuy_list, foreign_trend = self.data_fetcher.get_foreign_netbuy_trend(code)
            except Exception as e:
                self.logger.warning(f"‚ö†Ô∏è {name}({code}) Ïô∏Íµ≠Ïù∏ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå Ïã§Ìå®: {e}")
                foreign_netbuy_list, foreign_trend = [], "unknown"
            
            # Ï£ºÍ∞Ä Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå (Ïã§ÏãúÍ∞Ñ Ìè¨Ìï®)
            try:
                df = self.data_fetcher.get_daily_price_data_with_realtime(code)
            except Exception as e:
                self.logger.warning(f"‚ö†Ô∏è {name}({code}) Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞ Ïã§Ìå®, Í∏∞Î≥∏ Îç∞Ïù¥ÌÑ∞ ÏãúÎèÑ: {e}")
                try:
                    df = self.data_fetcher.get_daily_data(code)
                except Exception as e2:
                    self.logger.error(f"‚ùå {name}({code}) Î™®Îì† Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå Ïã§Ìå®: {e2}")
                    return False
            
            if df is None or df.empty:
                self.logger.warning(f"‚ö†Ô∏è {name}: Í∞ÄÍ≤© Îç∞Ïù¥ÌÑ∞Î•º Í∞ÄÏ†∏Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§.")
                return False
            
            # SignalAnalyzerÏóêÏÑú Ï†àÎåÄÏ°∞Í±¥ Ï≤¥ÌÅ¨ Î∞è Ï†êÏàò Í≥ÑÏÇ∞
            try:
                score, active_signals, passes_absolute, filter_reason = self.signal_analyzer.calculate_buy_signal_score(
                    df, name, code, foreign_trend=foreign_trend, foreign_netbuy_list=foreign_netbuy_list
                )
                
                # Ï†àÎåÄÏ°∞Í±¥ ÎØ∏ÌÜµÍ≥ºÏãú Î°úÍπÖ ÌõÑ Ï¢ÖÎ£å
                if not passes_absolute:
                    self.logger.debug(f"üö´ {name}({code}) Ï†àÎåÄÏ°∞Í±¥ ÎØ∏ÌÜµÍ≥º: {filter_reason}")
                    return True  # Î∂ÑÏÑùÏùÄ ÏÑ±Í≥µÌñàÏúºÎÇò Ï°∞Í±¥ ÎØ∏ÌÜµÍ≥º
                    
            except Exception as score_error:
                self.logger.error(f"‚ùå {name}({code}) Ï†êÏàò Í≥ÑÏÇ∞ Ïã§Ìå®: {score_error}")
                return False
            
            # ÌòÑÏû¨ Í∞ÄÍ≤© Ï†ïÎ≥¥ ÏïàÏ†ÑÌïòÍ≤å Ï∂îÏ∂ú
            try:
                # Ïª¨ÎüºÎ™Ö ÌÜµÏùº Ï≤òÎ¶¨
                if 'stck_clpr' in df.columns:
                    current_price = df.iloc[-1]["stck_clpr"]
                elif 'stck_prpr' in df.columns:
                    current_price = df.iloc[-1]["stck_prpr"]
                else:
                    current_price = 0
            
                if current_price > 300000:
                    self.logger.debug(f"üö´ {name}({code}) Íµ¨Îß§Í∞ÄÍ≤©Ïù¥ ÎÑàÎ¨¥ ÎÜíÏùå: {current_price/10000:.1f}ÎßåÏõê")
                    return True
                    
                if 'acml_vol' in df.columns:
                    volume = df.iloc[-1]["acml_vol"]
                elif 'cntg_vol' in df.columns:
                    volume = df.iloc[-1]["cntg_vol"]
                else:
                    volume = 0
                    
            except Exception as price_error:
                self.logger.warning(f"‚ö†Ô∏è {name}({code}) Í∞ÄÍ≤©Ï†ïÎ≥¥ Ï∂îÏ∂ú Ïã§Ìå®: {price_error}")
                current_price = 0
                volume = 0
    
            
            # Ï†êÏàòÎ≥Ñ Ï≤òÎ¶¨ - Í∞úÎ≥Ñ Ïã†Ìò∏ Í∏∞Î°ù
            if score >= self.min_score_for_detail:
                try:
                    individual_signals = self.signal_analyzer.get_individual_signals(df)
                    # üî• Î≤ÑÍ∑∏ ÏàòÏ†ï 1: score Ïù∏Ïûê Ï∂îÍ∞Ä
                    self._record_individual_signals(individual_signals, name, code, foreign_trend, score)
                except Exception as signal_error:
                    self.logger.warning(f"‚ö†Ô∏è {name}({code}) Í∞úÎ≥ÑÏã†Ìò∏ Î∂ÑÏÑù Ïã§Ìå®: {signal_error}")
            
            # Îã§Ï§ëÏã†Ìò∏ Îì±Í∏â Î∂ÑÎ•ò (Ï†àÎåÄÏ°∞Í±¥ ÌÜµÍ≥º Ï¢ÖÎ™©Îßå)
            stock_info = {
                "name": name, "code": code, "score": score,
                "signals": active_signals, "price": current_price, "volume": volume,
                "foreign": foreign_netbuy_list,
                "filter_status": "Ï†àÎåÄÏ°∞Í±¥ÌÜµÍ≥º",
                "filter_reason": filter_reason
            }
            self._classify_multi_signal_stock_filtered(stock_info)
            
            # üî• Î≤ÑÍ∑∏ ÏàòÏ†ï 2: _record_signal_combinationÏùÑ Ïù∏ÎùºÏù∏ ÏΩîÎìúÎ°ú ÍµêÏ≤¥
            # Ïã†Ìò∏ Ï°∞Ìï© Ìå®ÌÑ¥ Î∂ÑÏÑù (3Ï†ê Ïù¥ÏÉÅ)
            if score >= self.min_score_for_messaging and active_signals:
                combo_key = " + ".join(sorted(active_signals))
                if combo_key not in self.signal_combinations:
                    self.signal_combinations[combo_key] = []
                self.signal_combinations[combo_key].append(f"{name}({code})")
            
            # Î∞±ÌÖåÏä§Ìä∏ ÌõÑÎ≥¥ (3Ï†ê Ïù¥ÏÉÅ, Ï†àÎåÄÏ°∞Í±¥ ÌÜµÍ≥º)
            if score >= self.min_score_for_messaging:
                self.backtest_candidates.append({
                    "code": code,
                    "name": name,
                    "score": score,
                    "signals": active_signals,
                    "price": current_price,
                    "volume": volume,
                    "foreign_netbuy": foreign_netbuy_list,
                    "filter_status": "Ï†àÎåÄÏ°∞Í±¥ÌÜµÍ≥º",
                    "filter_reason": filter_reason,
                    "analysis_date": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                })
            
            return True
            
        except Exception as e:
            self.logger.error(f"‚ùå {name}({code}) Î∂ÑÏÑù Ïã§Ìå®: {e}")
            import traceback
            traceback.print_exc()
            return False
