    # trading_system/main.py ë§¤ë„ ë¡œì§ ê°œì„ 
    
    def process_sell_for_symbol_improved(self, symbol: str, position: dict):
        """
        ê°œì„ ëœ ê°œë³„ ì¢…ëª© ë§¤ë„ ì²˜ë¦¬ - ë” ì—„ê²©í•œ ì†ì ˆê³¼ ìœ ì—°í•œ ìµì ˆ
        """
        try:
            if symbol not in self.all_positions:
                return
                
            quantity = position['quantity']
            avg_price = position['avg_price']
            current_price = position['current_price']
            profit_loss_pct = position['profit_loss']
            profit_loss_decimal = profit_loss_pct / 100
            stock_name = self.get_stock_name(symbol)
            
            # ë³´ìœ  ê¸°ê°„ ê³„ì‚°
            position_summary = self.position_manager.get_position_summary(symbol)
            holding_days = self.calculate_holding_days(position_summary.get('first_purchase_time'))
            
            # 1ìˆœìœ„: ì—„ê²©í•œ ì†ì ˆ (ë¬´ì¡°ê±´ ì‹¤í–‰)
            stop_loss_threshold = self.get_dynamic_stop_loss(symbol, holding_days, profit_loss_decimal)
            
            if profit_loss_decimal <= stop_loss_threshold:
                self.logger.warning(f"ğŸ›‘ {stock_name}({symbol}) ì†ì ˆ ì‹¤í–‰! "
                                  f"({profit_loss_pct:+.2f}% <= {stop_loss_threshold:.1%})")
                self.execute_sell(symbol, quantity, "urgent", f"ì†ì ˆë§¤({stop_loss_threshold:.1%})")
                return
            
            # 2ìˆœìœ„: ë™ì  ìµì ˆ ì‹œìŠ¤í…œ
            take_profit_result = self.check_dynamic_take_profit(symbol, position, holding_days)
            if take_profit_result['should_sell']:
                can_sell, sell_reason = self.position_manager.can_sell_symbol(symbol, quantity)
                
                if can_sell:
                    self.logger.info(f"ğŸ¯ {stock_name}({symbol}) {take_profit_result['reason']} "
                                   f"({profit_loss_pct:+.2f}%)")
                    self.execute_sell(symbol, quantity, take_profit_result['urgency'], 
                                    take_profit_result['reason'])
                    return
                else:
                    self.logger.info(f"ğŸ’ {stock_name}({symbol}) ìµì ˆ ì¡°ê±´ì´ì§€ë§Œ ë³´ìœ  ì§€ì†: {sell_reason}")
            
            # 3ìˆœìœ„: ê¸°ìˆ ì  ë§¤ë„ ì‹ í˜¸ (ê±°ë˜ ëŒ€ìƒ ì¢…ëª©ë§Œ)
            if symbol in self.symbols:
                technical_sell = self.check_technical_sell_signal(symbol, position)
                if technical_sell['should_sell']:
                    can_sell, sell_reason = self.position_manager.can_sell_symbol(symbol, quantity)
                    
                    if can_sell:
                        self.logger.info(f"ğŸ“‰ {stock_name}({symbol}) ê¸°ìˆ ì  ë§¤ë„: {technical_sell['reason']}")
                        self.execute_sell(symbol, quantity, "aggressive_limit", technical_sell['reason'])
                        return
            
            # 4ìˆœìœ„: ë¦¬ë°¸ëŸ°ì‹± ë§¤ë„ (í¬íŠ¸í´ë¦¬ì˜¤ ë¹„ì¤‘ ì¡°ì •)
            rebalance_sell = self.check_rebalancing_sell(symbol, position)
            if rebalance_sell['should_sell']:
                partial_quantity = min(quantity, rebalance_sell['quantity'])
                self.logger.info(f"âš–ï¸ {stock_name}({symbol}) ë¦¬ë°¸ëŸ°ì‹± ë§¤ë„: {rebalance_sell['reason']}")
                self.execute_sell(symbol, partial_quantity, "patient_limit", rebalance_sell['reason'])
            
        except Exception as e:
            self.logger.error(f"{symbol} ë§¤ë„ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: {e}")
    
    
    def get_dynamic_stop_loss(self, symbol: str, holding_days: int, current_pnl: float) -> float:
        """
        ë™ì  ì†ì ˆ ê¸°ì¤€ - ë³´ìœ  ê¸°ê°„ê³¼ ìˆ˜ìµë¥ ì— ë”°ë¼ ì¡°ì •
        """
        base_stop_loss = -0.08  # ê¸°ë³¸ 8% ì†ì ˆ
        
        # ë³´ìœ  ê¸°ê°„ì— ë”°ë¥¸ ì¡°ì •
        if holding_days <= 1:        # 1ì¼ ì´ë‚´ - ì—„ê²©
            time_adjustment = 0.02   # 6% ì†ì ˆ
        elif holding_days <= 3:      # 3ì¼ ì´ë‚´ - ë³´í†µ
            time_adjustment = 0.0    # 8% ì†ì ˆ
        elif holding_days <= 7:      # 1ì£¼ ì´ë‚´ - ì—¬ìœ 
            time_adjustment = -0.02  # 10% ì†ì ˆ
        else:                        # ì¥ê¸° ë³´ìœ  - ë” ì—¬ìœ 
            time_adjustment = -0.04  # 12% ì†ì ˆ
        
        # í˜„ì¬ ìˆ˜ìµë¥ ì— ë”°ë¥¸ ì¡°ì • (ì´ìµ ë³´í˜¸)
        if current_pnl > 0.1:        # 10% ì´ìƒ ì´ìµ - ë³´í˜¸
            profit_adjustment = 0.05  # 3% ì†ì ˆë¡œ ê°•í™”
        elif current_pnl > 0.05:     # 5% ì´ìƒ ì´ìµ - ì¼ë¶€ ë³´í˜¸
            profit_adjustment = 0.03  # 5% ì†ì ˆë¡œ ê°•í™”
        else:
            profit_adjustment = 0.0
        
        final_stop_loss = base_stop_loss + time_adjustment + profit_adjustment
        
        return max(final_stop_loss, -0.15)  # ìµœëŒ€ 15% ì†ì ˆ í•œë„
    
    
    def check_dynamic_take_profit(self, symbol: str, position: dict, holding_days: int) -> Dict:
        """
        ë™ì  ìµì ˆ ì‹œìŠ¤í…œ - ì¶”ì„¸ì™€ ë³€ë™ì„±ì— ë”°ë¼ ì¡°ì •
        """
        profit_loss_decimal = position['profit_loss'] / 100
        current_price = position['current_price']
        
        # ê¸°ë³¸ ìµì ˆ ê¸°ì¤€
        base_take_profit = 0.25  # 25%
        
        try:
            # ìµœê·¼ ë°ì´í„°ë¡œ ì¶”ì„¸ ë¶„ì„
            df = self.api_client.get_daily_data(symbol, days=30)
            if df.empty:
                return {'should_sell': False, 'reason': 'ë°ì´í„°ì—†ìŒ'}
            
            # ì¶”ì„¸ ê°•ë„ ë¶„ì„
            trend_strength = self.analyze_trend_strength(df, current_price)
            
            # ë³€ë™ì„± ë¶„ì„
            volatility = self.calculate_recent_volatility(df)
            
            # ë™ì  ìµì ˆ ê¸°ì¤€ ì¡°ì •
            if trend_strength > 0.7:      # ê°•í•œ ìƒìŠ¹ ì¶”ì„¸ - ìµì ˆ ì—°ê¸°
                adjusted_take_profit = base_take_profit + 0.1  # 35%ê¹Œì§€ ì—°ê¸°
                urgency = "patient_limit"
            elif trend_strength > 0.3:    # ë³´í†µ ìƒìŠ¹ ì¶”ì„¸
                adjusted_take_profit = base_take_profit + 0.05  # 30%
                urgency = "patient_limit"
            elif trend_strength < -0.3:   # í•˜ë½ ì¶”ì„¸ - ë¹ ë¥¸ ìµì ˆ
                adjusted_take_profit = base_take_profit - 0.1   # 15%ë¡œ ì¡°ê¸° ìµì ˆ
                urgency = "aggressive_limit"
            else:                         # íš¡ë³´ - ê¸°ë³¸ ê¸°ì¤€
                adjusted_take_profit = base_take_profit
                urgency = "limit"
            
            # ë³€ë™ì„± ì¡°ì •
            if volatility > 0.06:         # ê³ ë³€ë™ì„± - ë³´ìˆ˜ì  ìµì ˆ
                adjusted_take_profit -= 0.05
                urgency = "aggressive_limit"
            
            # ë³´ìœ  ê¸°ê°„ ì¡°ì •
            if holding_days >= 14:        # 2ì£¼ ì´ìƒ - ì ì§„ì  ìµì ˆ
                adjusted_take_profit -= 0.05
            
            # ìµì ˆ ì¡°ê±´ í™•ì¸
            should_sell = profit_loss_decimal >= adjusted_take_profit
            
            return {
                'should_sell': should_sell,
                'reason': f"ë™ì ìµì ˆ({adjusted_take_profit:.1%})",
                'urgency': urgency,
                'threshold': adjusted_take_profit,
                'trend_strength': trend_strength
            }
            
        except Exception as e:
            # ì˜¤ë¥˜ ì‹œ ê¸°ë³¸ ìµì ˆ ê¸°ì¤€ ì‚¬ìš©
            should_sell = profit_loss_decimal >= base_take_profit
            return {
                'should_sell': should_sell,
                'reason': f"ê¸°ë³¸ìµì ˆ({base_take_profit:.1%})",
                'urgency': "limit"
            }
    
    
    def check_technical_sell_signal(self, symbol: str, position: dict) -> Dict:
        """
        ê¸°ìˆ ì  ë§¤ë„ ì‹ í˜¸ í™•ì¸ - ë” ì—„ê²©í•œ ê¸°ì¤€
        """
        try:
            # ì¼ë´‰ ë¶„ì„
            daily_analysis = self.hybrid_strategy.analyze_daily_strategy(symbol)
            
            # ê°•í•œ ë§¤ë„ ì‹ í˜¸ë§Œ ë°˜ì‘
            if (daily_analysis['signal'] == 'SELL' and 
                daily_analysis['strength'] >= 4.0):  # ê¸°ì¡´ 3.0 â†’ 4.0ìœ¼ë¡œ ìƒí–¥
                
                return {
                    'should_sell': True,
                    'reason': f"ê°•í•œê¸°ìˆ ì ë§¤ë„ì‹ í˜¸({daily_analysis['strength']:.1f})"
                }
            
            # ì¶”ê°€: ê¸‰ë½ ê°ì§€ ì‹œìŠ¤í…œ
            current_price = position['current_price']
            minute_df = self.api_client.get_minute_data(symbol, minutes=60)
            
            if not minute_df.empty:
                # 1ì‹œê°„ ë‚´ 5% ì´ìƒ ê¸‰ë½
                hour_ago_price = minute_df['stck_prpr'].iloc[0] if len(minute_df) > 0 else current_price
                hour_change = (current_price - hour_ago_price) / hour_ago_price
                
                if hour_change < -0.05:  # 5% ì´ìƒ ê¸‰ë½
                    return {
                        'should_sell': True,
                        'reason': f"ê¸‰ë½ê°ì§€({hour_change:.1%})"
                    }
            
            return {'should_sell': False, 'reason': 'ê¸°ìˆ ì ì‹ í˜¸ì—†ìŒ'}
            
        except Exception as e:
            return {'should_sell': False, 'reason': f'ë¶„ì„ì˜¤ë¥˜: {e}'}
    
    
    def check_rebalancing_sell(self, symbol: str, position: dict) -> Dict:
        """
        í¬íŠ¸í´ë¦¬ì˜¤ ë¦¬ë°¸ëŸ°ì‹± ë§¤ë„ í™•ì¸
        """
        try:
            total_portfolio_value = sum(pos.get('total_value', 0) for pos in self.all_positions.values())
            position_value = position.get('total_value', 0)
            
            if total_portfolio_value == 0:
                return {'should_sell': False, 'reason': 'í¬íŠ¸í´ë¦¬ì˜¤ê°’ì—†ìŒ'}
            
            position_weight = position_value / total_portfolio_value
            max_single_position = 0.4  # ë‹¨ì¼ ì¢…ëª© ìµœëŒ€ 40%
            
            if position_weight > max_single_position:
                # ì´ˆê³¼ ë¹„ì¤‘ë§Œí¼ ë§¤ë„
                excess_value = position_value - (total_portfolio_value * max_single_position)
                excess_quantity = int(excess_value / position['current_price'])
                
                return {
                    'should_sell': True,
                    'reason': f"ë¹„ì¤‘ì¡°ì •({position_weight:.1%}â†’{max_single_position:.1%})",
                    'quantity': max(excess_quantity, 1)
                }
            
            return {'should_sell': False, 'reason': 'ë¹„ì¤‘ì ì •'}
            
        except Exception as e:
            return {'should_sell': False, 'reason': f'ë¦¬ë°¸ëŸ°ì‹±ë¶„ì„ì˜¤ë¥˜: {e}'}
    
    
    def analyze_trend_strength(self, df: pd.DataFrame, current_price: float) -> float:
        """
        ì¶”ì„¸ ê°•ë„ ë¶„ì„ (-1: ê°•í•œ í•˜ë½, 0: íš¡ë³´, 1: ê°•í•œ ìƒìŠ¹)
        """
        try:
            if len(df) < 20:
                return 0
            
            # ì´ë™í‰ê· ì„  ë°°ì—´
            ma5 = df['stck_prpr'].rolling(5).mean().iloc[-1]
            ma10 = df['stck_prpr'].rolling(10).mean().iloc[-1]
            ma20 = df['stck_prpr'].rolling(20).mean().iloc[-1]
            
            # ê°€ê²© ìœ„ì¹˜ ì ìˆ˜
            price_score = 0
            if current_price > ma5 > ma10 > ma20:
                price_score = 1.0
            elif current_price > ma5 > ma10:
                price_score = 0.6
            elif current_price > ma5:
                price_score = 0.3
            elif current_price < ma20 < ma10 < ma5:
                price_score = -1.0
            elif current_price < ma10 < ma5:
                price_score = -0.6
            elif current_price < ma5:
                price_score = -0.3
            
            # ìµœê·¼ ê°€ê²© ë³€í™” ì¶”ì„¸
            recent_changes = df['stck_prpr'].pct_change().tail(5).sum()
            change_score = max(-0.5, min(0.5, recent_changes * 10))
            
            # ê±°ë˜ëŸ‰ ì¶”ì„¸
            vol_ma = df['acml_vol'].rolling(10).mean()
            recent_vol = df['acml_vol'].iloc[-1]
            vol_score = 0.2 if recent_vol > vol_ma.iloc[-1] * 1.2 else -0.1
            
            # ì¢…í•© ì ìˆ˜
            total_score = (price_score * 0.6) + (change_score * 0.3) + (vol_score * 0.1)
            
            return max(-1.0, min(1.0, total_score))
            
        except Exception:
            return 0
    
    
    def calculate_recent_volatility(self, df: pd.DataFrame, days: int = 10) -> float:
        """
        ìµœê·¼ ë³€ë™ì„± ê³„ì‚°
        """
        try:
            if len(df) < days:
                return 0.04
            
            recent_returns = df['stck_prpr'].pct_change().tail(days)
            volatility = recent_returns.std()
            
            return volatility if not pd.isna(volatility) else 0.04
            
        except Exception:
            return 0.04
    
    
    def calculate_holding_days(self, first_purchase_time: str) -> int:
        """
        ë³´ìœ  ì¼ìˆ˜ ê³„ì‚°
        """
        try:
            if not first_purchase_time:
                return 0
            
            purchase_time = datetime.fromisoformat(first_purchase_time)
            holding_period = datetime.now() - purchase_time
            
            return holding_period.days
            
        except Exception:
            return 0
    
    
    # ì¶”ê°€ ê°œì„ : íŠ¸ë ˆì¼ë§ ìŠ¤í†± ì‹œìŠ¤í…œ
    class TrailingStopManager:
        """
        íŠ¸ë ˆì¼ë§ ìŠ¤í†± ê´€ë¦¬ í´ë˜ìŠ¤
        """
        
        def __init__(self, logger):
            self.logger = logger
            self.trailing_stops = {}  # {symbol: {'highest_price': float, 'stop_price': float}}
        
        def update_trailing_stop(self, symbol: str, current_price: float, 
                               trailing_percent: float = 0.1) -> Dict:
            """
            íŠ¸ë ˆì¼ë§ ìŠ¤í†± ì—…ë°ì´íŠ¸
            """
            if symbol not in self.trailing_stops:
                self.trailing_stops[symbol] = {
                    'highest_price': current_price,
                    'stop_price': current_price * (1 - trailing_percent)
                }
                return {'should_sell': False, 'stop_price': self.trailing_stops[symbol]['stop_price']}
            
            stop_data = self.trailing_stops[symbol]
            
            # ì‹ ê³ ê°€ ê°±ì‹  ì‹œ ìŠ¤í†± ê°€ê²© ìƒí–¥ ì¡°ì •
            if current_price > stop_data['highest_price']:
                stop_data['highest_price'] = current_price
                new_stop_price = current_price * (1 - trailing_percent)
                
                # ìŠ¤í†± ê°€ê²©ì€ í•˜í–¥ ì¡°ì •ë˜ì§€ ì•ŠìŒ (íŠ¸ë ˆì¼ë§ íŠ¹ì„±)
                if new_stop_price > stop_data['stop_price']:
                    stop_data['stop_price'] = new_stop_price
                    self.logger.info(f"ğŸ“ˆ {symbol} íŠ¸ë ˆì¼ë§ ìŠ¤í†± ìƒí–¥: {new_stop_price:,.0f}ì›")
            
            # ìŠ¤í†± ì¡°ê±´ í™•ì¸
            should_sell = current_price <= stop_data['stop_price']
            
            return {
                'should_sell': should_sell,
                'stop_price': stop_data['stop_price'],
                'highest_price': stop_data['highest_price']
            }
        
        def remove_trailing_stop(self, symbol: str):
            """
            íŠ¸ë ˆì¼ë§ ìŠ¤í†± ì œê±° (ë§¤ë„ ì™„ë£Œ ì‹œ)
            """
            if symbol in self.trailing_stops:
                del self.trailing_stops[symbol]
    
    
    # main.pyì— íŠ¸ë ˆì¼ë§ ìŠ¤í†± ì ìš©
    def process_sell_with_trailing_stop(self, symbol: str, position: dict):
        """
        íŠ¸ë ˆì¼ë§ ìŠ¤í†±ì„ í¬í•¨í•œ ë§¤ë„ ì²˜ë¦¬
        """
        try:
            current_price = position['current_price']
            profit_loss_decimal = position['profit_loss'] / 100
            
            # ìˆ˜ìµ 10% ì´ìƒ ì‹œ íŠ¸ë ˆì¼ë§ ìŠ¤í†± í™œì„±í™”
            if profit_loss_decimal >= 0.1:
                if not hasattr(self, 'trailing_stop_manager'):
                    self.trailing_stop_manager = TrailingStopManager(self.logger)
                
                trailing_result = self.trailing_stop_manager.update_trailing_stop(
                    symbol, current_price, trailing_percent=0.08  # 8% íŠ¸ë ˆì¼ë§
                )
                
                if trailing_result['should_sell']:
                    stock_name = self.get_stock_name(symbol)
                    quantity = position['quantity']
                    
                    self.logger.info(f"ğŸ¯ {stock_name}({symbol}) íŠ¸ë ˆì¼ë§ ìŠ¤í†± ë°œë™! "
                                   f"í˜„ì¬ê°€: {current_price:,.0f}ì›, "
                                   f"ìŠ¤í†±ê°€: {trailing_result['stop_price']:,.0f}ì›")
                    
                    self.execute_sell(symbol, quantity, "urgent", "íŠ¸ë ˆì¼ë§ìŠ¤í†±")
                    self.trailing_stop_manager.remove_trailing_stop(symbol)
                    return
            
            # ê¸°ì¡´ ë§¤ë„ ë¡œì§ ì‹¤í–‰
            self.process_sell_for_symbol_improved(symbol, position)
            
        except Exception as e:
            self.logger.error(f"{symbol} íŠ¸ë ˆì¼ë§ ìŠ¤í†± ì²˜ë¦¬ ì˜¤ë¥˜: {e}")
            # ì˜¤ë¥˜ ì‹œ ê¸°ë³¸ ë§¤ë„ ë¡œì§ìœ¼ë¡œ í´ë°±
            self.process_sell_for_symbol_improved(symbol, position)
